#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include <WS2tcpip.h>
#include <Windows.h>
#include <iphlpapi.h>
#include <IcmpAPI.h>
#include <iostream>
#include <lm.h>
#include <string>
#include <vector>
#include <thread>
#include <fstream>
#include <sstream>

#pragma comment(lib, "Iphlpapi.lib")
#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "Netapi32.lib")

bool CheckSmbSharesAvailable(std::string);
LPWSTR ConvertToLPWSTR(const std::string&);
bool Ping(const std::string&);
std::string getAdapterInfo();
std::string ipAddressToString(DWORD);

std::vector<std::string> available_ips;
std::vector<std::thread> workers;
//std::vector<std::thread> shares_worker;

int main()
{
    std::string adapterInfo = getAdapterInfo();

    std::cout << "Available IPs found: " << available_ips.size() << std::endl;
    for (int i = 0; i < available_ips.size(); i++)
    {
        std::cout << "\n" << available_ips[i] << " : Checking SMB Shares...!!!  ----> ";
        CheckSmbSharesAvailable(available_ips[i]);
        //shares_worker.emplace_back(CheckSmbSharesAvailable, available_ips[i]);
    }

    /*for (auto& t : shares_worker) {
        t.join();
    }*/

    return 0;
}

bool Ping(const std::string& ipAddress)
{
    HANDLE hIcmpFile;
    unsigned long ipaddr = INADDR_NONE;
    DWORD dwRetVal = 0;
    char SendData[32] = "Data Buffer";
    LPVOID ReplyBuffer = NULL;
    DWORD ReplySize = 0;

    ipaddr = inet_addr(ipAddress.c_str());
    if (ipaddr == INADDR_NONE) {
        std::cout << "Invalid IP address" << std::endl;
        return false;
    }

    hIcmpFile = IcmpCreateFile();
    if (hIcmpFile == INVALID_HANDLE_VALUE) {
        std::cout << "Unable to create handle" << std::endl;
        return false;
    }

    ReplySize = sizeof(ICMP_ECHO_REPLY) + sizeof(SendData);
    ReplyBuffer = (VOID*)malloc(ReplySize);
    if (ReplyBuffer == NULL) {
        std::cout << "Unable to allocate memory" << std::endl;
        return false;
    }

    dwRetVal = IcmpSendEcho(hIcmpFile, ipaddr, SendData, sizeof(SendData),
        NULL, ReplyBuffer, ReplySize, 1000);

    if (dwRetVal != 0) {
        //std::cout << "Ping successful: " << ipAddress << std::endl;
        free(ReplyBuffer);
        IcmpCloseHandle(hIcmpFile);
        available_ips.push_back(ipAddress);
        return true;
    }
    else {
        //std::cout << "Ping failed ---> " << ipAddress << std::endl;
        free(ReplyBuffer);
        IcmpCloseHandle(hIcmpFile);
        return false;
    }
}

LPWSTR ConvertToLPWSTR(const std::string& str)
{
    // Determine the length of the wide character string.
    int len = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);

    // Allocate memory for the wide character string.
    LPWSTR wstr = new wchar_t[len];

    // Convert the std::string to a wide character string.
    MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, wstr, len);

    return wstr;
}

bool CheckSmbSharesAvailable(std::string ipAddress)
{
    NET_API_STATUS res;
    LPSHARE_INFO_2 pShares = NULL;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    DWORD i;

    // Call NetShareEnum to retrieve information about available shares.
    res = NetShareEnum(ConvertToLPWSTR(ipAddress), 2, (LPBYTE*)&pShares, MAX_PREFERRED_LENGTH, &dwEntriesRead, &dwTotalEntries, NULL);

    if (res == NERR_Success) {
        // If shares were found, free the memory and return true.
        if (dwEntriesRead > 0) {
            if (pShares != NULL) {
                NetApiBufferFree(pShares);
            }
            std::cout << " Shares found";
            return true;
        }
    }
    else {
        // If NetShareEnum failed, print an error message.
        //wprintf(L"NetShareEnum failed with error: %u\n", res);
        std::cout << "Network path not found";
        return false;
    }

    // Free the memory allocated by NetShareEnum.
    if (pShares != NULL) {
        NetApiBufferFree(pShares);
    }

    // If no shares were found or an error occurred, return false.
    std::cout << " Shares Not found";
    return false;
}

std::string getAdapterInfo() {
    PIP_ADAPTER_INFO adapterInfo = nullptr;
    PIP_ADAPTER_INFO adapter = nullptr;
    DWORD dwSize = sizeof(IP_ADAPTER_INFO);
    adapterInfo = (IP_ADAPTER_INFO*)malloc(dwSize);

    if (GetAdaptersInfo(adapterInfo, &dwSize) == ERROR_BUFFER_OVERFLOW) {
        free(adapterInfo);
        adapterInfo = (IP_ADAPTER_INFO*)malloc(dwSize);
    }

    std::stringstream result;
    if (GetAdaptersInfo(adapterInfo, &dwSize) == NO_ERROR) {
        adapter = adapterInfo;
        while (adapter) {
            result << "Adapter Name: " << adapter->AdapterName << std::endl;
            result << "IP Address: " << adapter->IpAddressList.IpAddress.String << std::endl;
            result << "Subnet Mask: " << adapter->IpAddressList.IpMask.String << std::endl;

            // Optionally, calculate and print the IP range
            DWORD ipAddr = inet_addr(adapter->IpAddressList.IpAddress.String);
            DWORD subnetMask = inet_addr(adapter->IpAddressList.IpMask.String);
            DWORD networkAddr = ipAddr & subnetMask;
            DWORD broadcastAddr = networkAddr | ~subnetMask;
            result << "Network: " << ipAddressToString(networkAddr) << " - Broadcast: " << ipAddressToString(broadcastAddr) << std::endl;

            // Enumerating the IP range
            std::string network_address_string = ipAddressToString(networkAddr);
            int num_threads = 255;
            for (int i = 0; i < 255; i++)
            {
                // increment in IP range
                std::string current_ip = network_address_string.replace(network_address_string.find_last_of(".") + 1, std::string::npos, std::to_string(i+1));

                // Pinging the IP in an async thread
                workers.emplace_back(Ping, current_ip);
            }

            // Join all the threads
            for (auto& t : workers) {
                t.join();
            }

            adapter = adapter->Next;
        }
    }

    if (adapterInfo)
        free(adapterInfo);

    return result.str();
}

std::string ipAddressToString(DWORD ipAddr) {
    struct in_addr addr;
    addr.S_un.S_addr = ipAddr;
    return inet_ntoa(addr);
}