using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security.Principal;

namespace NanoCore_testcase11
{
    internal class Program
    {
        [DllImport("ntdll.dll")]
        public static extern int NtSetInformationProcess(IntPtr processHandle, int processInformationClass, ref int processInformation, int processInformationLength);

        private static bool set_critical_config = true;

        static void Main(string[] args)
        {
            if (!CheckElevation())
            {
                //exit
                Console.WriteLine("Elevated Privileges Required...!!!");
                Environment.Exit(1);
            }

            if (SetCritical(set_critical_config))
            {
                Console.WriteLine("Process is Set to Critical");
                Console.WriteLine("Do not close the process with Process Name: "+ Process.GetCurrentProcess().ProcessName +" and Process ID: "+ Process.GetCurrentProcess().Id);
                Console.WriteLine("OR SYSTEM WILL CRASH");
            }
            else
            {
                Console.WriteLine("Failed");
            }

            // Wait for user input here to examine the process
            Console.ReadLine();
        }

        private static bool SetCritical(bool critical) 
        {
            try
            {
                IntPtr currentProcessHandle = Process.GetCurrentProcess().Handle;
                if (currentProcessHandle != IntPtr.Zero)
                {
                    Process.EnterDebugMode();
                    int num = critical ? 1 : 0;
                    int num2 = NtSetInformationProcess(currentProcessHandle, 29, ref num, 4);
                    if (num2 != 0)
                    {
                        //Class8.smethod_86(new Exception(string.Format("Call to NtSetInformationProcess has failed with error code {0:X}", num2)), "UpdateProcessBreakOnTermination");

                        Console.WriteLine("Call to NtSetInformationProcess has failed with error code {0:X}", num2);
                        return false;
                    }
                    Process.LeaveDebugMode();
                    return true;
                }
                else
                {
                    Console.WriteLine("Failed to retrieve handle to the current module.");
                    return false;
                }
            }
            catch (Exception exception_)
            {
                //Class8.smethod_86(exception_, "UpdateProcessBreakOnTermination");
                Console.WriteLine("UpdateProcessBreakOnTermination: " + exception_);
                return false;
            }
        }

        private static bool CheckElevation()
        {
            WindowsIdentity identity = WindowsIdentity.GetCurrent();
            WindowsPrincipal principal = new WindowsPrincipal(identity);

            bool isElevated = principal.IsInRole(WindowsBuiltInRole.Administrator);

            if (isElevated)
                return true;
            else
                return false;
        }
    }
}
