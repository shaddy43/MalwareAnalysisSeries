#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <windows.h>
#include <vector>

// Patch Structure definition
struct PatchStructure {
    unsigned char* byteArray;
    LPVOID address;
    int size;

    // Function to initialize PatchStructure with a given size
    void initializePatchStructure(PatchStructure& patch, int size) {
        patch.size = size;
        patch.byteArray = new unsigned char[size];
        // Ensure that byteArray is properly initialized (e.g., set all elements to 0)
        std::memset(patch.byteArray, 0, size);
    }

    // Function to release dynamically allocated memory
    void releasePatchStructure(PatchStructure& patch) {
        delete[] patch.byteArray;
    }
};

struct PatchSize {
    std::size_t firstIndex;
    std::size_t bytesBetween;
};

int main();
void DummyFunctionToModify();
PatchSize findSignature(const std::vector<unsigned char>&, const std::vector<unsigned char>&);
PatchStructure ReadProcess();
void PatchCurrentProcessMemory(void*, void*, size_t);
unsigned char* xorByteArray(unsigned char*, int, unsigned char);

// Example function to modify
void DummyFunctionToModify() {

    // Load shell32.dll
    HMODULE hModule = LoadLibrary(L"shell32.dll");
    if (hModule == NULL) {
        std::cerr << "Failed to load shell32.dll\n";
        return;
    }

    // Get the address of ShellExecuteA
    FARPROC pShellExecuteA = GetProcAddress(hModule, "ShellExecuteA");
    if (pShellExecuteA == NULL) {
        std::cerr << "Failed to get address of ShellExecuteA\n";
        FreeLibrary(hModule); // Don't forget to free the library
        return;
    }

    // Command and parameters for ShellExecuteA
    const char* operation = "open";
    const char* file = "cmd.exe";
    const char* parameters = "/c start powershell";
    const char* directory = NULL; // Use the current directory
    int showCmd = SW_SHOW;

    std::cout << "Execution using ShellExecuteA...." << std::endl;
    std::cout << "Command: " << file << " " << parameters << std::endl;

    // Inline assembly is highly specific to the compiler and platform.
    // The following is an example for 32-bit applications compiled with specific versions of MSVC that support this syntax.
    // Below this line, the code sandwiched in nop instructions must be patched and replaced with encrypted bytes, which will be decrypted in memory by program itself
    
    __asm {
        nop //9090909090
        nop
        nop
        nop
        nop

        push showCmd           // nShowCmd
        push directory         // lpDirectory
        push parameters        // lpParameters
        push file              // lpFile
        push operation         // lpOperation
        push 0                 // hWnd
        mov eax, pShellExecuteA
        call eax               // Call ShellExecuteA

        nop
        nop
        nop
        nop
        nop
    }

    // Free the loaded library
    FreeLibrary(hModule);
}

PatchSize findSignature(const std::vector<unsigned char>& buffer, const std::vector<unsigned char>& signature) {
    std::size_t bytesBetween;
    std::size_t bufferLength = buffer.size();
    std::size_t signatureLength = signature.size();
    std::size_t firstIndex = std::string::npos; // Initialize first index to not found

    for (std::size_t i = 0; i <= bufferLength - signatureLength; ++i) {
        bool found = true;
        for (std::size_t j = 0; j < signatureLength; ++j) {
            if (buffer[i + j] != signature[j]) {
                found = false;
                break;
            }
        }
        if (found) {
            if (firstIndex == std::string::npos) {
                // First occurrence of the signature, store its index
                firstIndex = i;
            }
            else {
                // Calculate the number of bytes between two occurrences
                bytesBetween = i - firstIndex - signatureLength;
                std::cout << "Number of bytes between two occurrences: " << bytesBetween << std::endl;
            }
        }
    }

    PatchSize patch_size_object;
    patch_size_object.firstIndex = firstIndex;
    patch_size_object.bytesBetween = bytesBetween;

    return patch_size_object; // Return the index where the first signature is found
}

PatchStructure ReadProcess()
{
    // Get a handle to the current process
    std::cout << "[x] Read Process Memory....!!!" << std::endl;
    HANDLE hProcess = GetCurrentProcess();

    // Get the base address of the executable module
    HMODULE hModule;
    if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, reinterpret_cast<LPCWSTR>(&main), &hModule)) {
        std::cerr << "Failed to get module handle." << std::endl;
        return {};
    }

    // Get the DOS header
    IMAGE_DOS_HEADER dosHeader;
    if (!ReadProcessMemory(hProcess, hModule, &dosHeader, sizeof(dosHeader), nullptr)) {
        std::cerr << "Failed to read DOS header." << std::endl;
        return {};
    }

    // Get the NT headers
    IMAGE_NT_HEADERS ntHeaders;
    if (!ReadProcessMemory(hProcess, reinterpret_cast<BYTE*>(hModule) + dosHeader.e_lfanew, &ntHeaders, sizeof(ntHeaders), nullptr)) {
        std::cerr << "Failed to read NT headers." << std::endl;
        return {};
    }

    // Get the section headers
    IMAGE_SECTION_HEADER sectionHeader;
    DWORD textSectionRVA = 0; // RVA of the .text section
    DWORD textSectionSize = 0; // Size of the .text section

    std::cout << "[x] Finding .text section....!!!" << std::endl;
    // Iterate over the section headers to find the .text section
    for (int i = 0; i < ntHeaders.FileHeader.NumberOfSections; ++i) {
        if (!ReadProcessMemory(hProcess, reinterpret_cast<BYTE*>(hModule) + dosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER)),
            &sectionHeader, sizeof(sectionHeader), nullptr)) {
            std::cerr << "Failed to read section header." << std::endl;
            return {};
        }
        if (strcmp(reinterpret_cast<const char*>(sectionHeader.Name), ".text") == 0) {
            textSectionRVA = sectionHeader.VirtualAddress;
            textSectionSize = sectionHeader.SizeOfRawData;
            break;
        }
    }

    if (textSectionRVA == 0) {
        std::cerr << "Failed to find .text section." << std::endl;
        return {};
    }

    // Read the .text section into memory
    std::vector<unsigned char> buffer(textSectionSize);
    SIZE_T bytesRead;
    if (!ReadProcessMemory(hProcess, reinterpret_cast<BYTE*>(hModule) + textSectionRVA, buffer.data(), textSectionSize, &bytesRead)) {
        std::cerr << "Failed to read .text section." << std::endl;
        return {};
    }

    // Finding Signature Bytes
    std::cout << "[x] Finding signature bytes....!!!" << std::endl;
    std::vector<unsigned char> signature = { 0x90, 0x90, 0x90, 0x90, 0x90 };

    // Search for the signature in the buffer
    PatchSize patch_size_object = findSignature(buffer, signature);
    std::size_t changeByteIndex = patch_size_object.firstIndex + 5;

    if (patch_size_object.firstIndex != std::string::npos) {
        std::cout << "Signature found at index: [0x" << std::hex << patch_size_object.firstIndex << "]" << std::endl;
    }
    else {
        std::cout << "Signature not found in the buffer." << std::endl;
    }

    //Copy bytes in the structure values
    PatchStructure patchObject;
    patchObject.initializePatchStructure(patchObject, patch_size_object.bytesBetween);

    const int numBytes = patch_size_object.bytesBetween;
    std::size_t changeByteIndexEnumerator = changeByteIndex;
    std::cout << "Encrypted Bytes: " << std::endl;
    std::cout << "[ ";
    for (int i = 0; i < numBytes; i++) {
        patchObject.byteArray[i] = buffer[changeByteIndexEnumerator++];
        std::cout << "0x" << std::hex << static_cast<int>(patchObject.byteArray[i]) << " ";
    }
    std::cout << "]";

    std::cout << "" << std::endl;
    std::cout << "[x] Getting relative address of Encrypted bytes....!!!" << std::endl;

    // Get the base address of the module in memory
    LPVOID moduleBaseAddress = hModule;
    // Calculate the base address of the .text section by adding the RVA
    LPVOID textSectionBaseAddress = reinterpret_cast<LPBYTE>(moduleBaseAddress) + textSectionRVA;

    // Calculate the address of the specific location
    patchObject.address = static_cast<LPBYTE>(textSectionBaseAddress) + changeByteIndex;
  
    std::cout << "Address of the Bytes location: [" << patchObject.address << "]" << std::endl;
    return patchObject;
}


void PatchCurrentProcessMemory(void* destination, void* source, size_t size) {
    
    // Change memory protection to execute-read-write
    DWORD oldProtect;
    if (!VirtualProtect(destination, size, PAGE_EXECUTE_READWRITE, &oldProtect)) {
        std::cerr << "Failed to change memory protection." << std::endl;
        return;
    }

    // Copy the new bytes into the destination
    memcpy(destination, source, size);

    // Restore the original memory protection
    DWORD temp;
    VirtualProtect(destination, size, oldProtect, &temp);
}

unsigned char* xorByteArray(unsigned char* byteArray, int length, unsigned char key) {
    for (int i = 0; i < length; ++i) {
        byteArray[i] ^= key; // XOR each byte with the key
    }

    return byteArray;
}

int main() {

    //Find bytes
    PatchStructure patch_object = ReadProcess();
    
    //Xor enc function
    std::cout << "[x] Decrypting the bytes found in memory....!!!" << std::endl;
    unsigned char patch_key = 0xA7;
    unsigned char* decByteArray = xorByteArray(patch_object.byteArray, patch_object.size, patch_key);
    std::cout << "Decrypted bytes: " << std::endl;
    std::cout << "[ ";
    for (int i = 0; i < patch_object.size; i++) {
        std::cout << "0x" << std::hex << static_cast<int>(decByteArray[i]) << " ";
    }
    std::cout << "]" << std::endl;
    
    //Patch bytes
    std::cout << "[x] Patching Memory with decrypted bytes....!!!" << std::endl;
    PatchCurrentProcessMemory(patch_object.address, decByteArray, patch_object.size);

    //Execute patched function
    std::cout << "[x] Executing Decrypted Patched Function....!!!" << std::endl;
    DummyFunctionToModify();
    std::cout << "[x] Successfully executed. Spawned powershell....!!!" << std::endl;
    return 0;
}